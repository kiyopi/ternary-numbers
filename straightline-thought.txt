<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【思考直線プロセス版】座標キューヲメンデ変換シミュレータ</title>
    <style>
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background-color: #121212; color: #e0e0e0; display: flex; height: 100vh; overflow: hidden; }
        #main-container { display: flex; flex-grow: 1; }
        #controls-panel { width: 380px; padding: 20px; background-color: #1e1e1e; box-shadow: 2px 0 5px rgba(0,0,0,0.5); z-index: 10; display: flex; flex-direction: column; border-right: 1px solid #333; overflow-y: auto;}
        h1 { font-size: 1.5em; margin-top: 0; color: #bb86fc; }
        p { font-size: 0.9em; line-height: 1.6; color: #b0b0b0; }
        .input-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #bb86fc; }
        input[type="range"] { width: 100%; }
        .info-section { margin-top: 20px; padding: 15px; background-color: #2a2a2a; border-radius: 4px; }
        .info-section h3 { margin-top: 0; font-size: 1.2em; padding-bottom: 10px; border-bottom: 1px solid #444;}
        .info-section p { margin: 10px 0; font-size: 1em; word-wrap: break-word; line-height: 1.5; }
        .tengu-color-box { display: inline-block; width: 1em; height: 1em; margin-right: 8px; vertical-align: middle; }
        #canvas-container { flex-grow: 1; display: flex; justify-content: center; align-items: center; }
        canvas { background-color: #000000; }
    </style>
</head>
<body>

    <div id="main-container">
        <div id="controls-panel">
            <h1>思考直線プロセス シミュレータ</h1>
            <p>思考の発展段階（面）と、それを司るtenguの関係性をシミュレートします。</p>

            <div class="input-group">
                <label for="step-slider">思考の発展段階 (1〜15)</label>
                <input type="range" id="step-slider" min="1" max="15" value="3">
            </div>

            <div id="info-panel" class="info-section">
                <h3 id="info-title"></h3>
                <p id="info-sides"></p>
                <p id="info-hypotenuse"></p>
            </div>
        </div>
        <div id="canvas-container">
            <canvas id="spiral-canvas"></canvas>
        </div>
    </div>

    <script>
        // --- DOM要素 ---
        const slider = document.getElementById('step-slider');
        const canvas = document.getElementById('spiral-canvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvas-container');

        const infoTitle = document.getElementById('info-title');
        const infoSides = document.getElementById('info-sides');
        const infoHypotenuse = document.getElementById('info-hypotenuse');

        // --- tenguの定義 ---
        const TENGU_MAP = {
            1: { name: '苔tengu', color: '#00dd00' }, // 緑
            2: { name: '朱tengu', color: '#ff4444' }, // 赤
            3: { name: '空tengu', color: '#4488ff' }, // 青
        };

        function toCustomNotation(num) {
            if (Math.abs(num - Math.round(num)) < 1e-9) return `${Math.round(num)}√1√1`;
            const squared = num * num;
            if (Math.abs(squared - Math.round(squared)) < 1e-9) return `1√${Math.round(squared)}√1`;
            return `1√${squared.toFixed(2)}√1`;
        }
        
        function draw() {
            const steps = parseInt(slider.value);
            const size = Math.min(canvasContainer.clientWidth, canvasContainer.clientHeight);
            canvas.width = size;
            canvas.height = size;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);

            let scale = size / (Math.sqrt(steps + 2) * 2.5);
            let hypotenuse = 1;
            let angle = 0;
            
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1;

            for (let i = 1; i <= steps; i++) {
                const prevHypotenuse = hypotenuse;
                hypotenuse = Math.sqrt(hypotenuse * hypotenuse + 1);
                const newAngle = Math.atan(1 / prevHypotenuse);

                const isLastStep = (i === steps);

                // 三角形を描画
                ctx.beginPath();
                ctx.moveTo(0, 0);
                const p1x = prevHypotenuse * scale;
                const p1y = 0;
                const p2x = prevHypotenuse * scale;
                const p2y = -1 * scale;
                ctx.lineTo(p1x, p1y);
                ctx.lineTo(p2x, p2y);
                ctx.closePath();
                
                if(isLastStep) {
                    const tengu = TENGU_MAP[i] || { name: '発展領域', color: '#bb86fc' };
                    ctx.fillStyle = hexToRgba(tengu.color, 0.3);
                    ctx.fill();
                    ctx.strokeStyle = tengu.color;
                    ctx.lineWidth = 2;
                } else {
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 1;
                }
                ctx.stroke();
                
                // 次の三角形のために回転
                ctx.rotate(-newAngle);
                angle += newAngle;
            }
            
            ctx.restore();

            // 情報パネルを更新
            updateInfoPanel(steps);
        }
        
        function updateInfoPanel(step) {
            const tengu = TENGU_MAP[step] || { name: `${step + 1}d の発展領域`, color: '#bb86fc' };
            
            const sideA = Math.sqrt(step);
            const sideB = 1;
            const hypotenuse = Math.sqrt(step + 1);

            infoTitle.innerHTML = `<span class="tengu-color-box" style="background-color:${tengu.color};"></span>${step + 1}d: ${tengu.name}`;
            infoTitle.style.color = tengu.color;
            
            infoSides.innerHTML = `構成辺: ${toCustomNotation(sideA)} と ${toCustomNotation(sideB)}`;
            infoHypotenuse.innerHTML = `<strong>斜辺 (次の面の基底): ${toCustomNotation(hypotenuse)}</strong>`;
        }
        
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        slider.addEventListener('input', draw);
        window.addEventListener('resize', draw);

        draw();
    </script>

</body>
</html>